<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | thecave | Ramblings from a crotchety old man]]></title>
  <link href="http://www.thecave.com/category/ios/atom.xml" rel="self"/>
  <link href="http://www.thecave.com/"/>
  <updated>2014-09-14T14:53:57-04:00</updated>
  <id>http://www.thecave.com/</id>
  <author>
    <name><![CDATA[Kirby Turner]]></name>
    
  </author>

  
  <entry>
    <title type="html"><![CDATA[Cross Posting to App.net, Facebook, and Twitter]]></title>
    <link href="http://www.thecave.com/2014/09/14/cross-posting-to-app.net-facebook-and-twitter/"/>
    <updated>2014-09-14T00:00:00-04:00</updated>
    <id>http://www.thecave.com/2014/09/14/cross-posting-to-app.net-facebook-and-twitter</id>
    <content type="html"><![CDATA[<p>Last year my wife told me more family and friends would “like” my photos on Facebook if I posted the them directly to Facebook. At the time I was using <a href="https://ifttt.com">ifttt</a> to selectively cross post to App.net and Facebook. This meant my photos on Facebook were actually links to the App.net, which is where the photos were being stored, and this required my Facebook followers to tap the link to see the photos. Not the best experience for my followers.</p>

<p>I decided to test my wife’s theory by posting photos directly to Facebook. Turns out she was right. I started getting more likes. Not only that, I found that family and friends posted more comments when I posted the photos directly. My wife was right. Posting photos directly to the social site is the best experience for followers and the best to become more engaged with your followers.</p>

<p>Now I could have setup an ifttt recipe that cross posted my Facebook photos to App.net, but that means my followers on App.net would have the less than ideal experience reading my posts and viewing my photos. So I started down the path of exploring different options for cross posting between different social networks.</p>

<p>After exploring options for nearly six months, I learned there is no single solution that will cross post to different social networks while giving the followers on each network the best viewing experience. So I set out to write my own app.</p>

<p>I quickly learned why no cross post solution that posts natively to each social network existed. It’s hard, and in the case of Facebook, nearly impossible to make the post look as if it were posted from the official app. But I figured it out and for the past few months I have been making posts using Cross Post.</p>

<p>Cross Post is the app I’ve been working on for the last few months. I’ve also been using it almost daily for months. The app was ready for public release back in August, but I decided to wait until the iOS 8 release. The primary reason for this is to avoid annoying iPhone 4 users. iPhone 4 cannot run iOS 8, and I had planned to drop support for iOS 7 the moment iOS 8 is released. So I decided to delay the release of Cross Post.</p>

<p>The delayed release gave me time to work on adding some new iOS 8 only features. One feature in particular that I’m very excited about is the share extension. This feature makes it possible for a person to cross post to different social networks from other apps running on their iPhone or iPad. This feature alone makes Cross Post much more useful than I ever imagined 6 months ago.</p>

<p>When I started learning the ins and outs of share extensions I thought to myself, “This will be a snap.” But as I got deeper into the code I realized Cross Post has one major issue that makes the Cross Post share extension suck. It takes Cross Post too damn long to post photos to multiple social sites.</p>

<p>Consider the scenario where you want to post 4 photos to App.net, Facebook, and Twitter. Each photo must be uploaded to each network. That means 12 different uploads, which is not speedy. This performance problem is acceptable in the Cross Post app because it performs the uploads even when the app is no longer active. A share extension, on the other hand, should return almost immediately. It should not, or have to, wait for the uploads to complete.</p>

<p>Extensions that need to upload data should do so using a background <code>NSURLSession</code>. Unfortunately this is not an option for Cross Post because it uses the Facebook SDK to post to Facebook and <code>SLRequest</code> to post to Twitter. Cross Post does use <code>NSURLSession</code> to post to App.net, but I want to be able to post to Facebook and Twitter via the share extension as well. So I needed to come up with a better way to post status updates and photos across different social networks.</p>

<p>To solve this problem I decided to create a Cross Post server. I was trying to avoid having a server for Cross Post, but it’s unavoidable if I want to provide the best user experience. With the server in place Cross Post can upload the post and photos once and let the server handle uploading the content to the selected networks. Best of all, the upload from the app can be accomplished using a single <code>NSURLSession</code> request, and it can be performed in a background session. This means the Cross Post share extension can return almost immediately. It also means that Cross Post now only needs to make one HTTP request whereas previously it had to make numerous requests. For instance, the previous scenario of posting 4 photos to 3 different social sites required 15 HTTP requests. Now Cross Post app accomplishes the same thing using a single HTTP request<sup id="fnref:onerequest"><a href="#fn:onerequest" class="footnote">1</a></sup>, and the Cross Post server handles making all the other requests on behalf of the app.</p>

<p>This performance boost does have some disadvantages. First and foremost, I’m now responsible for keeping the server environment up and running. But thanks to <a href="https://www.openshift.com">OpenShift</a>, I’m not too worried about that.</p>

<p>Another disadvantage is that reporting errors back to the iOS app is going to be more challenging. Cross Post and the share extension sends off the request to the server. Once the server receives the payload the HTTP connection ends. The server, however, continues working by posting the payload to the selected social sites. If there is an error posting to, say, Twitter, there is no way for the server to tell the Cross Post app because that connection no longer exist. I have some ideas on how to solve this problem, but it’s not going to happen in the first release.</p>

<p>Still, the improved user experience outweighs the disadvantages of using a server. And I have to admit, I’m enjoying getting back into server-side programming. So much as changed, for the better, over the years.</p>

<div class="footnotes">
  <ol>
    <li id="fn:onerequest">
      <p>I was able to reducing the number of calls to the server down to one by packaging the post and photos into a single .zip file, which is sent to the server. <a href="#fnref:onerequest" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iPhone 6 and 6 Plus Pocket Test]]></title>
    <link href="http://www.thecave.com/2014/09/10/iphone-6-plus-pocket-test/"/>
    <updated>2014-09-10T00:00:00-04:00</updated>
    <id>http://www.thecave.com/2014/09/10/iphone-6-plus-pocket-test</id>
    <content type="html"><![CDATA[<p><a href="https://flic.kr/p/pa23Ro"><img src="https://farm6.staticflickr.com/5581/15198258832_1daebf3355_m.jpg" border="0" class="alignleft" /></a> I printed out this <a href="http://arstechnica.com/apple/2014/09/how-big-is-the-iphone-6-plus-find-out-with-our-handy-paper-template/">iPhone 6 and 6 Plus paper template</a>. I cut out each template and taped cardboard to the back. Then I did a pocket test with each one. I tested each template with different pants and shorts that I wear often. I found that both the iPhone 6 and iPhone 6 Plus fit in all my pockets, but a corner of the iPhone 6 Plus cutout does stick out of the pocket on my gym shorts. I also found that while the iPhone 6 Plus does fit in the pockets of my Levis 501, my jeans of choice, the cutout was annoyingly noticeable when I sat down.</p>

<p>For those wondering, I’m 5 foot 6 and typically wear 32 inch waist pants and shorts. Taller folks with roomier pants and shorts might not notice the size difference of the Plus as much as I did.</p>

<p>As for holding the two cutouts, I found that the iPhone 6 cutout fits comfortably and securely in my hand. The iPhone 6 Plus cutout, on the other hand, just feels too big to hold and use with one hand. Granted I have small hands, but in acting like I’m interacting with a real iPhone I found I kept using two hands with the iPhone 6 Plus whereas I was comfortable using only one hand with the iPhone 6 cutout.</p>

<p>Conclusion: I will be buying the iPhone 6. The larger display of the iPhone 6 Plus would be nice for reading and watching shows and movies, but it’s just too damn large to be pocket device for me.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Wait, Justin and I Agree?]]></title>
    <link href="http://www.thecave.com/2014/05/10/wait-justin-and-i-agree/"/>
    <updated>2014-05-10T00:00:00-04:00</updated>
    <id>http://www.thecave.com/2014/05/10/wait-justin-and-i-agree</id>
    <content type="html"><![CDATA[<p>My friend Justin wrote a post explaining why he thinks you should <a href="http://carpeaqua.com/2014/05/09/why-you-should-use-interface-builder-with-auto-layout/">use Interface Builder with Auto Layout</a>. It was in response to my post about <a href="http://www.thecave.com/2014/05/04/i-stopped-using-nibs-thanks-to-auto-layout/">why I don’t use Interface Builder</a> these days thanks to Auto Layout. Justin’s post is good with plenty of valid points. Justin and I also agree iOS and Mac developers should be using Auto Layout. But he said something that got me wondering…does Justin agree with me more than he realizes. Regarding writing layout constraints in code, Justin says:</p>

<blockquote>
  <p>It’s totally possible to do this, and there are situations where I do it as well. Small views with a few basic constraints are usually quicker and easier to write without a Xib. Insanely complex views such as the TED video player I wrote and maintain are also too heavy for a straight Xib implementation.</p>
</blockquote>

<p>I found that almost all the apps I have worked on in recent years consists of views that fall into the category of either being small views or complex views. And even “insanely complex views” can likely be broken down into smaller views using the <a href="http://stackoverflow.com/a/13581816">composite view pattern</a>. In other words, in my experience many views can be broken down into smaller, more manageable views that end up needing only a few basic constraints. And even Justin agrees that “small views with a few basic constraints are usually quicker and easier to write without a Xib.” So it’s my style, my approach to solving UI problems that makes it quicker and easier for me to write UI with layout constraints in code rather than using IB.</p>

<p>Does this mean I’m right and Justin is wrong? No. Does it mean Justin’s right and I’m wrong? No.</p>

<p>In programming there are multiple ways to accomplish a task, and one approach isn’t always necessarily better or more right than another approach. The approach a programmer takes to solve a problem is often based on past experience and the solution often reflects the personal style of the programmer.</p>

<p>Over the years my style has changed and evolved to a point where I break down complex problems into smaller, more manageable tasks, and I use this style, or approach if you will, when implementing a UI. These days view controller containment and composite views work well for me. I like to write <a href="http://www.objc.io/issue-1/lighter-view-controllers.html">light weight view controllers</a>, and I use other objects to serve as the data source and delegate to my view controllers. And more recently I have found I don’t need to use Interface Builder to be a productive programmer.</p>

<p>Does this mean you should abandon IB as well? Certainly not. Does this mean I hate IB and I will never use it again? Most certainly not. When a task I need to accomplish is quicker and easier for me to do in IB, then I will most certainly use IB. Just like Justin will sometimes write layout constraints in code, I will sometimes use IB to put together a view.</p>

<p>Different situations call for different solutions. There isn’t just one way to solve a problem, and programmers shouldn’t do something just because one person says this is the way it should be done. Programmers should explore the different ways to accomplish a task, and decide what works best for them and what tools and approaches make them the best, most productive programmer they can be. And don’t get hung up on doing a task the same way each time. Challenge yourself by find new ways of accomplishing the same task. In doing this, you might find you agree much more with the person that you thought you disagreed with on the onset.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I Stopped Using NIBs Thanks to Auto Layout]]></title>
    <link href="http://www.thecave.com/2014/05/04/i-stopped-using-nibs-thanks-to-auto-layout/"/>
    <updated>2014-05-04T00:00:00-04:00</updated>
    <id>http://www.thecave.com/2014/05/04/i-stopped-using-nibs-thanks-to-auto-layout</id>
    <content type="html"><![CDATA[<p>The subject to this post might suggest I don’t like Auto Layout, but on the contrary I really like Auto Layout. I didn’t always like Auto Layout. For the longest time Auto Layout was a major pain in my ass, but it turns out it was Interface Builder that was causing me the majority of headaches when I used Auto Layout. So I stopped using Auto Layout in IB and I started using it in code only.</p>

<p>It took me a while to get comfortable with Auto Layout in code, but once things clicked, I found it easy to get the layout I wanted. In fact, I have found Auto Layout saves me time when laying out a UI, and I’ve become so comfortable with Auto Layout that now I become annoyed if I have to work on a project that does not use Auto Layout.</p>

<p>Because I use Auto Layout in code I realized overtime I was using Interface Builder only to define the UI elements that made up the view. I would define all the Auto Layout constraints in code. This got me thinking, why do I need to define the UI elements in IB? So I did a small project with no NIBs or storyboards, and I loved it. I felt more productive, and I was banging my head against the wall a hell of a lot less.</p>

<p>(Credit also goes to <a href="https://twitter.com/mattie">Matt Massicotte</a> for encouraging me to try a project with no NIB or storboard files.)</p>

<p>I’ve now done a number of iOS projects where I don’t use a single NIB or storyboard, and I’m convinced this is the right approach for me. I see everything regarding a view and its subviews explicitly defined in source code, which makes it easier to see what’s going on and to make changes. No more bouncing between inspectors to figure out what is causing a problem or to understand how a view is rendered. I see it all in the source code defined in a single <em>.m</em> file.</p>

<p>So how do I construct my views using only source code? I have a base class that I call <a href="https://github.com/kirbyt/WPSKit/blob/master/WPSKit/UIKit/WPSCompositeView.h"><code>WPSCompositeView</code></a> in my <a href="https://github.com/kirbyt/WPSKit">WPSKit</a>, a set of classes and categories I use to build apps. <code>WPSCompositeView</code> has a class method named <code>+addToSuperview:</code> that creates the instance of the view, which must be a subclass of <code>WPSCompositeView</code>, then calls <code>-loadView</code> on the instance of the view. I place all the code needed to create the subviews of the view in the <code>-loadView</code> implementation. The constraints for the view are implemented in the <code>-updateConstraints</code> that is called by iOS when needed. That’s it.</p>

<p>Here’s an example of a composer view for a new app I’m working on:</p>

<p><a href="https://farm8.staticflickr.com/7204/13920896030_4c53fbfe1c_o.jpg"><img src="https://farm8.staticflickr.com/7204/13920896030_e0da352daf_m.jpg" alt="" /></a></p>

<p>And the code for creating this view is as follows:</p>

<pre><code>- (void)loadView
{
  UIView *containerView = self;

  WPSTextView *textView = [[WPSTextView alloc] init];
  [textView setTranslatesAutoresizingMaskIntoConstraints:NO];
  [textView setAlwaysBounceVertical:YES];
  [textView setInputAccessoryView:[self toolbar]];
  [textView setFont:[UIFont systemFontOfSize:17.0]];
  [textView setPlaceholderText:NSLocalizedString(@"What's up?", @"Placeholder text.")];
  [self setTextView:textView];

  UIButton *locationButton = [UIButton buttonWithType:UIButtonTypeCustom];
  [locationButton setTranslatesAutoresizingMaskIntoConstraints:NO];
  [locationButton setImage:[UIImage wps_imageNamed:@"location" withMaskColor:[UIColor lightGrayColor]] forState:UIControlStateNormal];
  [locationButton setImage:[UIImage wps_imageNamed:@"location" withMaskColor:[UIColor wps_iOSDefaultBlue]] forState:UIControlStateSelected];
  [locationButton setSelected:NO];
  [locationButton addTarget:self action:@selector(_locationButtonTapped:) forControlEvents:UIControlEventTouchUpInside];
  [self setLocationButton:locationButton];

  UILabel *locationLabel = [[UILabel alloc] init];
  [locationLabel setTranslatesAutoresizingMaskIntoConstraints:NO];
  [locationLabel setTextColor:[UIColor lightGrayColor]];
  [locationLabel setTextAlignment:NSTextAlignmentLeft];
  [locationLabel setText:NSLocalizedString(@"Location Disabled", @"Location text.")];
  [self setLocationLabel:locationLabel];

  UILabel *characterCountLabel = [[UILabel alloc] init];
  [characterCountLabel setTranslatesAutoresizingMaskIntoConstraints:NO];
  [characterCountLabel setTextColor:[UIColor lightGrayColor]];
  [characterCountLabel setTextAlignment:NSTextAlignmentRight];
  [self setCharacterCountLabel:characterCountLabel];

  [containerView addSubview:textView];
  [containerView addSubview:locationButton];
  [containerView addSubview:locationLabel];
  [containerView addSubview:characterCountLabel];

  [textView wps_setDidChange:^(UITextView *aTextView) {
    NSString *countString = nil;
    NSUInteger length = [[aTextView text] length];
    if (length &gt; 0) {
      countString = [NSString stringWithFormat:@"%lu", (unsigned long)length];
    }
    [characterCountLabel setText:countString];
  }];
}

- (void)updateConstraints
{
  WPSTextView *textView = [self textView];
  UILabel *characterCountLabel = [self characterCountLabel];
  UIButton *locationButton = [self locationButton];
  UILabel *locationLabel = [self locationLabel];

  [locationButton wps_constrainToHeight:38.0f];
  [locationButton wps_constrainToWidth:38.0f];

  NSDictionary *bindings = NSDictionaryOfVariableBindings(textView, characterCountLabel, locationButton, locationLabel);
  [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-0-[textView]-4-[characterCountLabel]-0-|" options:0 metrics:nil views:bindings]];
  [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-0-[textView]-0-|" options:0 metrics:nil views:bindings]];
  [self addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-8-[locationButton]-[locationLabel]-[characterCountLabel]-8-|" options:0 metrics:nil views:bindings]];
  [self addConstraint:[NSLayoutConstraint constraintWithItem:locationLabel attribute:NSLayoutAttributeBaseline relatedBy:NSLayoutRelationEqual toItem:characterCountLabel attribute:NSLayoutAttributeBaseline multiplier:1.0 constant:0.0]];
  [self addConstraint:[NSLayoutConstraint constraintWithItem:locationButton attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:locationLabel attribute:NSLayoutAttributeCenterY multiplier:1.0 constant:0.0]];

  [super updateConstraints];
}

- (UIToolbar *)toolbar
{
  if (_toolbar == nil) {
    CGRect screenBounds = [[UIScreen mainScreen] bounds];
    UIToolbar *toolbar = [[UIToolbar alloc] initWithFrame:CGRectMake(0, 0, screenBounds.size.width, 44)];
    [toolbar setTintAdjustmentMode:UIViewTintAdjustmentModeNormal];


    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    BOOL adnOn = [defaults cp_isAdnOn];
    BOOL facebookOn = [defaults cp_isFacebookOn];
    BOOL twitterOn = [defaults cp_isTwitterOn];

    UIColor *offColor = [UIColor lightGrayColor];
    UIColor *adnColor = adnOn ? [UIColor blackColor] : offColor;
    UIColor *facebookColor = facebookOn ? [UIColor wps_facebookBlue] : offColor;
    UIColor *twitterColor = twitterOn ? [UIColor wps_twitterBlue] : offColor;

    UIBarButtonItem *cameraButton = [self buttonWithImageName:@"camera" color:[UIColor wps_iOSDefaultBlue] action:@selector(_cameraButtonTapped:)];
    [self setCameraButton:cameraButton];

    UIBarButtonItem *adnButton = [self buttonWithImageName:@"adn" color:adnColor action:@selector(_adnButtonTapped:)];
    [adnButton setTag:adnOn];
    [self setAdnOn:adnOn];
    [self setAdnButton:adnButton];

    UIBarButtonItem *facebookButton = [self buttonWithImageName:@"facebook" color:facebookColor action:@selector(_facebookButtonTapped:)];
    [facebookButton setTag:facebookOn];
    [self setFacebookOn:facebookOn];
    [self setFacebookButton:facebookButton];

    UIBarButtonItem *twitterButton = [self buttonWithImageName:@"twitter" color:twitterColor action:@selector(_twitterButtonTapped:)];
    [twitterButton setTag:twitterOn];
    [self setTwitterOn:twitterOn];
    [self setTwitterButton:twitterButton];

    UIBarButtonItem *draftsButton = [self buttonWithImageName:@"drafts" color:[UIColor wps_iOSDefaultBlue] action:@selector(_draftsButtonTapped:)];
    [self setDraftsButton:draftsButton];

    UIBarButtonItem *flexibleButton = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
    [toolbar setItems:@[adnButton, facebookButton, twitterButton, flexibleButton, draftsButton, cameraButton] animated:NO];

    _toolbar = toolbar;
  }
  return  _toolbar;
}
</code></pre>

<p>The only things not created or managed but this view are the navigation bar and collection view of photos. The navigation bar is provided by the <code>UINavigationController</code> used by the view controller that created this composer view. Also, the view controller uses controller containment to include the collection view of photos, which is actually managed by another view controller and custom view class.</p>

<p>Oh, I almost forgot to mention…I create the composite view in the <code>loadView</code> method implemented in the view controller. For example:</p>

<pre><code>- (void)loadView
{
  [super loadView];
  UIView *contentView = [self view];

  CPComposeView *composeView = [CPComposeView addToSuperview:contentView];
  [self setComposeView:composeView];
}
</code></pre>

<p>After I create the view I might add more layout constraints to position and size the subview as needed within the main content view. I do that in the view controller’s <code>-loadView</code> when needed.</p>

<p>So that’s it. That’s why I have stopped using NIB and storyboard files in my iOS projects. This approach might not work for others, but it certainly works for me.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Send Camera Video to Your TV]]></title>
    <link href="http://www.thecave.com/2013/11/20/send-your-camera-video-to-your-tv/"/>
    <updated>2013-11-20T00:00:00-05:00</updated>
    <id>http://www.thecave.com/2013/11/20/send-your-camera-video-to-your-tv</id>
    <content type="html"><![CDATA[<p>Believe it or not, I finally released a new app for iOS. It’s my first new app for <a href="http://www.whitepeaksoftware.com/">White Peak Software</a> in more than 2 years. Somewhere along the way over the last two years I lost my way, but I’m back. </p>

<p>So what’s this new app? It’s <a href="http://www.whitepeaksoftware.com/big-screen">Big Screen</a>.</p>

<p>Big Screen lets you view the video from your iPhone or iPad’s camera on your TV. It requires an AppleTV, or other AirPlay receiver. Sure, you can use the built-in iOS 7 camera app to do the same, but you will see the app’s chrome on the TV. With Big Screen, there is no chrome or any other evidence that the app is being used. This makes Big Screen ideal for presentation, conferences, and other events where large screen TVs are used to let viewers in the room see the action on the stage.</p>

<p>I got the idea to write an <a href="http://www.whitepeaksoftware.com/main/big-screen/why">app to display the camera’s video on a TV</a> while attending an event at Rowan’s elementary school. It just goes to show you never know when a new app idea will pop up.</p>

<p>Big Screen is a free app available now in the iOS App Store. <a href="http://www.whitepeaksoftware.com/main/store/buy/big-screen">Grab a copy</a>, and let me know what you think.</p>

]]></content>
  </entry>
  
</feed>